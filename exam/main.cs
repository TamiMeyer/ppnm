using System;
using static System.Console;
using static System.Math;
using System.Collections.Generic;
public class main{
    public static int Main(){
        int n_example = 7;//n>=7 
        double lambda_example =1.0;

        WriteLine("---Task A-------");
        WriteLine("The least-squares signal smoothing is implemented using Gram-Schmidt QR-decomposition to solve the linear equation A*y_smooth=y_raw. \n");
        
        //print matrices (just for demonstration)
        WriteLine("Example of matrix D: The second derivative of a discrete signal is approximated by its secondorder difference, Dx,");
        WriteLine("where the matrix D (e.g. for a set of 5 datapoints) is given as:");
        matrix D = smooth.secondDerivative(n_example);
        D.print("D = ");
        WriteLine();
        WriteLine("Example of matrix A for smoothing parameter lambda = 1 and 5 data points:");
        matrix A = smooth.lineqMatrix(lambda_example,n_example);
        A.print("A = 1+Î»D^TD =  ");
        WriteLine();

        WriteLine(@"See 'Out.smoothQR.svg':
        The figure shows a noisy signal (generated by chatGPT) and the smoothened signal 
        (using QR-decomposition) with 3 different smoothing parameters lambda.");
        WriteLine();
        //Read the raw noisy signal data from the file
        List<double> x_raw_list = new List<double>{};
        List<double> y_raw_list = new List<double>{};
        var instream=new System.IO.StreamReader("signal.data");
        instream.ReadLine(); //skip the first line (it contains the title)
        char[] split_delimiters = {' ','\t','\n'};
        var split_options = System.StringSplitOptions.RemoveEmptyEntries;
        for(string line=instream.ReadLine(); line!=null; line=instream.ReadLine()){  
	        var numbers = line.Split(split_delimiters,split_options);
            x_raw_list.Add(double.Parse(numbers[0]));
            y_raw_list.Add(double.Parse(numbers[1]));
        }
        instream.Close();
        double[] x_raw = x_raw_list.ToArray();
        double[] y_raw = y_raw_list.ToArray();
        vector y_raw_vec = new vector(y_raw);

        //smoothing with QR-decomposition for different lambda values
        double lambda_a = 1;
        double lambda_b = 8;
        double lambda_c = 80;
        vector y_smooth_a = smooth.smoothQR(y_raw_vec, lambda_a);
        vector y_smooth_b = smooth.smoothQR(y_raw_vec, lambda_b);
        vector y_smooth_c = smooth.smoothQR(y_raw_vec, lambda_c);

        //write noisy and smooth data to new file
        var outstream=new System.IO.StreamWriter("Out.smoothsignalQR.data", append:false);
        outstream.WriteLine($"x y_raw lambda={lambda_a} lambda={lambda_b} lambda={lambda_c}");
        for(int i=0; i<y_raw_vec.size; i++){
            outstream.WriteLine($"{x_raw[i]} {y_raw[i]} {y_smooth_a[i]} {y_smooth_b[i]} {y_smooth_c[i]}");
        }

        WriteLine("---Task B-------");
        WriteLine(@"See 'Out.smoothQR_generated.svg':
        Signal with random noise is generated. And the smoothing with QR-decomposition is applied.");
        WriteLine();
        //generate clean and noisy signal with SIN-function
        ////Func<double, double> sin_func = delegate(double z){return Math.Sin(z);};
        Func<double, double> clean_func = delegate(double z){return Pow(z,6)-3*Pow(z,5)-7*Pow(z,4)+15*Pow(z,3);};
        var (x, y_clean, y_noisy) = smooth.generateCleanAndNoisySignal(500, clean_func, -2.5, 2.5, 15);

        //smoothing with QR-decomposition
        double lambda = 8000;
        vector y_smooth = smooth.smoothQR(y_noisy, lambda);

        //write clean,noisy and smooth data to new file
        var outstream2=new System.IO.StreamWriter("Out.smoothsignalQR_generated.data", append:false);
        outstream2.WriteLine($"x y_clean y_noisy lambda={lambda}");
        for(int i=0; i<y_noisy.size; i++){
            outstream2.WriteLine($"{x[i]} {y_clean[i]} {y_noisy[i]} {y_smooth[i]}");
        }

        WriteLine("---Task C.1-------");
        WriteLine(@"The matrix A in this linear equation is pentadiagonal banded (has only 5 non-zero diagonals)
therefore in order to make the method efficient, instead of QR-decopmposition, we use this fact in LU factorization.
Before making use of the banded structure, I will implement LU factorization of a matrix. And show with an example that it works.

The linear equation A*y_smooth=y_raw is solved by LU factorization (here I still work with matrices which contain lots of zeros). For the example A from above:
");

        var (L,U) = smooth.LUdecomp(A);
        L.print("L = ");
        U.print("U = ");
        matrix LU = L*U;
        LU.print("Test: LU = ");
        WriteLine($"LU=A? => {LU.approx(A)} \n");

        WriteLine(@"See 'Out.smoothsignalLU_generated.svg':
        The LU factorization of the A matrix is applied for smoothing the generated data from the previous task (to make sure the LU factorization works).
        LU achieves the same result as QR, as can be seen from the figure or by comparing the data files of the smoothed signals.");
        WriteLine();
        //clean and noisy data has already been generated: y_clean, y_noisy
        //smoothing with LU-decomposition
        y_smooth = smooth.smoothLU(y_noisy, lambda);

        //write clean,noisy and smooth data to new file
        var outstream3=new System.IO.StreamWriter("Out.smoothsignalLU_generated.data", append:false);
        outstream3.WriteLine($"x y_clean y_noisy lambda={lambda}");
        for(int i=0; i<y_noisy.size; i++){
            outstream3.WriteLine($"{x[i]} {y_clean[i]} {y_noisy[i]} {y_smooth[i]}");
        }

        WriteLine("---Task C.2-------");
        WriteLine(@"Now, we make use of the banded structure of the A matrix, the fact that A is symmetric and that the each non-zero diagonal is just a 
constant except from the ends of the diagonal (i.e. the corner elements).

First, I reduced the number of computations required to determine the matrix A and reduced the required storage for A by getting rid of the zeros in the A matrix.
The A matrix is fully determined by only 9 values: 4 values of the main diagonal (a), 3 values of the sub- and superdiagonal (b), 2 values of the subsub- and supersuperdiagonal (c).
The diagonal elements for the previous example are:");
        var (a,b,c) = smooth.lineqMatrix_eff(lambda_example);
        WriteLine("");
        a.print("a=");
        b.print("b=");
        c.print("c=");
        WriteLine();

        WriteLine("Secondly, an LU decomposition method for the A matrix with its special structure was implemented. L and U are banded matrices.");
        var(l,ll,lll,u,uu,uuu) = smooth.LUdecomp_eff(n_example, a, b, c);
        WriteLine("The main diagonal of L is determined by:");
        l.print("l= ");
        WriteLine("The subdiagonal of L is:");
        ll.print("ll= ");
        WriteLine("The subsubdiagonal of L is:");
        lll.print("lll= ");
        WriteLine("The supersuperdiagonal of U is determined by:");
        uuu.print("uuu= ");
        WriteLine("The superdiagonal of U is:");
        uu.print("uu= ");
        WriteLine("The maindiagonal of U is:");
        u.print("u= ");
        WriteLine();

        WriteLine("Thirdly, a method 'smoothLU_eff' was implemented, that smoothenes a noisy signal vector and makes use of the banded structure of the L and U matrices. ");
        //clean and noisy data has already been generated: y_clean, y_noisy
        //smoothing with LU-decomposition
        vector y_smooth_eff = smooth.smoothLU_eff(y_noisy, lambda);

        //write clean,noisy and smooth data to new file
        var outstream4=new System.IO.StreamWriter("Out.smoothsignalLU_generated_eff.data", append:false);
        outstream4.WriteLine($"x y_clean y_noisy lambda={lambda}");
        for(int i=0; i<y_noisy.size; i++){
            outstream4.WriteLine($"{x[i]} {y_clean[i]} {y_noisy[i]} {y_smooth_eff[i]}");
        }
       
        outstream.Close();
        outstream2.Close();
        outstream3.Close();
        outstream4.Close();

        return 0;
    }
}