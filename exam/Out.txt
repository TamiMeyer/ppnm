---Task A-------
The least-squares signal smoothing is implemented using Gram-Schmidt QR-decomposition to solve the linear equation A*y_smooth=y_raw. 

Example of matrix D: The second derivative of a discrete signal is approximated by its secondorder difference, Dx,
where the matrix D (e.g. for a set of 5 datapoints) is given as:
D = 
         1         -2          1          0          0          0          0 
         1         -2          1          0          0          0          0 
         0          1         -2          1          0          0          0 
         0          0          1         -2          1          0          0 
         0          0          0          1         -2          1          0 
         0          0          0          0          1         -2          1 
         0          0          0          0          1         -2          1 

Example of matrix A for smoothing parameter lambda = 1 and 5 data points:
A = 1+Î»D^TD =  
         3         -4          2          0          0          0          0 
        -4         10         -6          1          0          0          0 
         2         -6          8         -4          1          0          0 
         0          1         -4          7         -4          1          0 
         0          0          1         -4          8         -6          2 
         0          0          0          1         -6         10         -4 
         0          0          0          0          2         -4          3 

See 'Out.smoothQR.svg':
        The figure shows a noisy signal (generated by chatGPT) and the smoothened signal 
        (using QR-decomposition) with 3 different smoothing parameters lambda.

---Task B-------
See 'Out.smoothQR_generated.svg':
        Signal with random noise is generated. And the smoothing with QR-decomposition is applied.

---Task C.1-------
The matrix A in this linear equation is pentadiagonal banded (has only 5 non-zero diagonals)
therefore in order to make the method efficient, instead of QR-decopmposition, we use this fact in LU factorization.
Before making use of the banded structure, I will implement LU factorization of a matrix. And show with an example that it works.

The linear equation A*y_smooth=y_raw is solved by LU factorization (here I still work with matrices which contain lots of zeros). For the example A from above:

L = 
         1          0          0          0          0          0          0 
     -1.33          1          0          0          0          0          0 
     0.667     -0.714          1          0          0          0          0 
         0      0.214     -0.767          1          0          0          0 
         0          0      0.233     -0.758          1          0          0 
         0          0          0      0.234     -0.986          1          0 
         0          0          0          0      0.376     -0.441          1 
U = 
         3         -4          2          0          0          0          0 
         0       4.67      -3.33          1          0          0          0 
         0          0       4.29      -3.29          1          0          0 
         0          0          0       4.27      -3.23          1          0 
         0          0          0          0       5.32      -5.24          2 
         0          0          0          0          0        4.6      -2.03 
         0          0          0          0          0          0       1.35 
Test: LU = 
         3         -4          2          0          0          0          0 
        -4         10         -6          1          0          0          0 
         2         -6          8         -4          1          0          0 
         0          1         -4          7         -4          1          0 
         0          0          1         -4          8         -6          2 
         0          0          0          1         -6         10         -4 
         0          0          0          0          2         -4          3 
LU=A? => True 

See 'Out.smoothsignalLU_generated.svg':
        The LU factorization of the A matrix is applied for smoothing the generated data from the previous task (to make sure the LU factorization works).
        LU achieves the same result as QR, as can be seen from the figure or by comparing the data files of the smoothed signals.

---Task C.2-------
Now, we make use of the banded structure of the A matrix, the fact that A is symmetric and that the each non-zero diagonal is just a 
constant except from the ends of the diagonal (i.e. the corner elements).

First, I reduced the number of computations required to determine the matrix A and reduced the required storage for A by getting rid of the zeros in the A matrix.
The A matrix is fully determined by only 9 values: 4 values of the main diagonal (a), 3 values of the sub- and superdiagonal (b), 2 values of the subsub- and supersuperdiagonal (c).
The diagonal elements for the previous example are:

a=         3         10          8          7 
b=        -4         -6         -4 
c=         2          1 

Secondly, an LU decomposition method for the A matrix with its special structure was implemented. L and U are banded matrices.
The main diagonal of L is determined by:
l=          1 
The subdiagonal of L is:
ll=      -1.33     -0.714     -0.767     -0.758     -0.986     -0.441 
The subsubdiagonal of L is:
lll=      0.667      0.214      0.233      0.234      0.376 
The supersuperdiagonal of U is determined by:
uuu=          2          1 
The superdiagonal of U is:
uu=         -4      -3.33      -3.29      -3.23      -5.24      -2.03 
The maindiagonal of U is:
u=          3       4.67       4.29       4.27       5.32        4.6       1.35 

Thirdly, a method 'smoothLU_eff' was implemented, that smoothenes a noisy signal vector and makes use of the banded structure of the L and U matrices. 
